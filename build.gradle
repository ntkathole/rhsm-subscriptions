import groovy.json.JsonOutput

buildscript {
    // dependabot will parse dependencies.gradle by detecting the `apply from` below
    apply from: "dependencies.gradle"
}

plugins {
    id "swatch.spring-boot-conventions"
    id "org.sonarqube"
    id "nebula.release"
    id 'com.adarshr.test-logger'
}

group = "org.candlepin"

dependencies {
    implementation project(':swatch-core')
    implementation project(":api")
    implementation project(":clients:cloudigrade-client")
    implementation project(":clients:cloudigrade-internal-client")
    implementation project(":clients:insights-inventory-client")
    implementation project(":clients:rh-marketplace-client")
    implementation project(":clients:product-client")
    implementation project(":clients:prometheus-client")
    implementation project(":clients:rbac-client")
    implementation project(":clients:rhsm-client")
    implementation project(":clients:subscription-client")
    implementation project(":clients:user-client")
    implementation project(":kafka-schema")

    implementation("io.confluent:kafka-avro-serializer") {
        exclude group: "org.apache.kafka"
        // A transitive dependency, org.apache.zookeeper:zookeeper, includes log4j as well as slf4j.  We use
        // logback and SLF4J issues a warning if more than one logging implementation is on the classpath.
        // Frowny face to Zookeeper for adding a logging implementation to a library jar.
        exclude group: "org.slf4j", module: "slf4j-log4j12"
    }

    implementation "org.springframework.boot:spring-boot-starter-data-jpa"
    implementation "org.springframework.kafka:spring-kafka"
    // the following dep is necessary to avoid jackson kotlin warnings
    implementation "com.fasterxml.jackson.module:jackson-module-kotlin"

    implementation "org.liquibase:liquibase-core"
    implementation "org.postgresql:postgresql"

    testImplementation "org.springframework.security:spring-security-test"
    testImplementation "org.springframework.kafka:spring-kafka-test"
    testImplementation project(':swatch-core-test')

    runtimeOnly "org.hsqldb:hsqldb"
}

allprojects {
    // Add a custom task to output dependency info in a machine parseable format. Used to generate dependency
    // reports for Product Security.
    // adapted from https://stackoverflow.com/a/34641632
    // easiest to use via `./gradlew -q dependencyJson`
    tasks.register('dependencyJson') {
        doLast {
            def collectDeps = { ResolvedDependency dependency ->
                def collectedDeps = []
                // depth first traversal
                def dependencyStack = [dependency]
                while (!dependencyStack.isEmpty()) {
                    ResolvedDependency current = dependencyStack.pop()
                    collectedDeps.add(current)
                    current.children.forEach { dependencyStack.push(it) }
                }
                return collectedDeps
            }
            Set allDeps = []
            def projects = allprojects
                    .grep { project -> !project.name.endsWith("-test") }
                    .grep { project -> 'default' in project.configurations.names }
            for (Project project : projects) {
                // see https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management
                // "default" is all artifacts required at runtime
                for (ResolvedDependency topLevelDependency : project.configurations.default.resolvedConfiguration.firstLevelModuleDependencies) {
                    def collectedDeps = collectDeps(topLevelDependency)
                    for (ResolvedDependency dependency : collectedDeps) {
                        // skip deps that appear to be from this project
                        if (dependency.moduleGroup != project.group || dependency.moduleVersion != project.version) {
                            allDeps.add([
                                    group  : dependency.moduleGroup,
                                    name   : dependency.moduleName,
                                    version: dependency.moduleVersion,
                            ])
                        }
                    }

                }
            }
            println JsonOutput.toJson(allDeps.sort { "${it.group}:${it.name}:${it.version}" })
        }
    }
}


compileJava.dependsOn(processResources)
project.tasks["sonarqube"].dependsOn "test"
project.tasks["sonarqube"].dependsOn "jacocoTestReport"

project(":api") {
    apply plugin: "swatch.java-conventions"
    apply plugin: "swatch.spring-boot-dependencies-conventions"
    apply plugin: "org.openapi.generator"

    ext {
        api_spec_path = "${projectDir}/rhsm-subscriptions-api-spec.yaml"
        internal_api_spec_path = "${projectDir}/internal-rhsm-subscriptions-api-spec.yaml"
        config_file = "${projectDir}/rhsm-subscriptions-api-config.json"
    }

    openApiGenerate {
      generatorName = "jaxrs-spec"
      inputSpec = api_spec_path
      configFile = config_file
      outputDir = "$buildDir/generated"
      configOptions = [
          interfaceOnly: "true",
          generatePom: "false",
          dateLibrary: "java8",
      ]
    }

    task generateInternalApi(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "jaxrs-spec"
        inputSpec = internal_api_spec_path
        configFile = config_file
        outputDir = "$buildDir/generated"
        configOptions = [
                interfaceOnly: "true",
                generatePom: "false",
                dateLibrary: "java8",
        ]
    }

    task validateApiSpec(type: org.openapitools.generator.gradle.plugin.tasks.ValidateTask){
        inputSpec = api_spec_path
    }

    task validateInternalApiSpec(type: org.openapitools.generator.gradle.plugin.tasks.ValidateTask){
        inputSpec = internal_api_spec_path
    }

    task validateSpecs(dependsOn: ['validateApiSpec', 'validateInternalApiSpec'])

    task generateApiDocs(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "html"
        inputSpec = api_spec_path
        outputDir = "$buildDir/docs"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateOpenApiJson(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "openapi"
        inputSpec = api_spec_path
        outputDir = "$buildDir/generated/openapijson"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateInternalApiDocs(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "html"
        inputSpec = internal_api_spec_path
        outputDir = "$buildDir/docs"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    task generateInternalOpenApiJson(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
        generatorName = "openapi"
        inputSpec = internal_api_spec_path
        outputDir = "$buildDir/generated/internalopenapijson"
        generateApiDocumentation = true
        generateModelDocumentation = true
        generateModelTests = false
        generateApiTests = false
        withXml = false
    }

    processResources {
        with copySpec {
            from "$buildDir/generated/openapijson/openapi.json"
            from api_spec_path
            rename { String fileName ->
                api_spec_path.endsWith(fileName) ? 'openapi.yaml' : fileName  // rename yaml to openapi.yaml
            }
        }
        with copySpec {
            //TODO: this makes gradle complain about duplicate files even with the rename. Need to look into fix
//            from "$buildDir/generated/internalopenapijson/openapi.json"
//            rename { String fileName -> 'internalopenapi.yaml' // rename yaml to internalopenapi.yaml
//            }
            from internal_api_spec_path
            rename { String fileName ->
                internal_api_spec_path.endsWith(fileName) ? 'internalopenapi.yaml' : fileName  // rename yaml to internalopenapi.yaml
            }
        }
    }

    dependencies {
        implementation "javax.annotation:javax.annotation-api"
        implementation "com.fasterxml.jackson.core:jackson-annotations"
        implementation "javax.validation:validation-api"
        implementation "org.jboss.spec.javax.ws.rs:jboss-jaxrs-api_2.1_spec"
        implementation "io.swagger:swagger-annotations"
        implementation "com.google.code.findbugs:jsr305:3.0.2"
        implementation "org.openapitools:jackson-databind-nullable:0.2.2"
    }

    sourceSets.main.java.srcDirs = ["${buildDir}/generated/src/gen/java"]
    compileJava.dependsOn tasks.openApiGenerate
    compileJava.dependsOn tasks.generateInternalApi
    processResources.dependsOn tasks.generateInternalApi
    processResources.dependsOn tasks.openApiGenerate
    processResources.dependsOn tasks.generateOpenApiJson
    processResources.dependsOn tasks.generateInternalOpenApiJson


}

project(":kafka-schema") {
    apply plugin: "swatch.java-conventions"
    apply plugin: "swatch.spring-boot-dependencies-conventions"
    apply plugin: "com.github.davidmc24.gradle.plugin.avro"

    dependencies {
        implementation "org.apache.avro:avro"
    }

    task generateAvro(type: com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask) {
        // sub dir needed so that the plugin does not traverse into the build dir (if it exists).
        source("${projectDir}/avro")
        outputDir = file("${buildDir}/generated/avro/src/main/java")
    }

    sourceSets.main.java.srcDirs += "${buildDir}/generated/avro/src/main/java"
    compileJava.source(generateAvro.outputs)
    compileJava.dependsOn tasks.generateAvro
}
